The content of the file (source code) is as follows:
```python
import streamlit as st
import sqlite3
import subprocess
import signal
import os
import json

# DB Setup
conn = sqlite3.connect('emails.db', check_same_thread=False)
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS emails (
        name TEXT PRIMARY KEY,
        email TEXT NOT NULL
    )
''')
conn.commit()

# Functions
def add_email(name, email):
    try:
        cursor.execute("INSERT INTO emails (name, email) VALUES (?, ?)", (name, email))
        conn.commit()
        return True
    except sqlite3.IntegrityError:
        return False

def reset_email():
    try:
        cursor.execute('DELETE FROM emails')
        conn.commit()
        return True
    except sqlite3.IntegrityError:
        return False

def get_all_emails():
    cursor.execute('SELECT * FROM emails')
    return cursor.fetchall()

def write_emails():
    mail_list = get_all_emails()
    with open('email_list.json',  'w') as f:
        json.dump(mail_list, f)

# Streamlit App
st.title('üìß Mail Reader')

st.write('')

if 'monitor_process' not in st.session_state:
    st.session_state.monitor_process = None

st.write('Press this button to start monitoring the emails')

col1, col2, col3 = st.columns(3)

with col1:
    if st.button('MONITOR'):
        if st.session_state.monitor_process is None or st.session_state.monitor_process.poll() is not None:
            write_emails()
            st.session_state.monitor_process = subprocess.Popen(['python', 'monitor.py'])
            st.success("Monitoring started.")
        else:
            st.info("Already running.")

with col2:
    if st.button('STOP'):
        proc = st.session_state.monitor_process
        if proc and proc.poll() is None:
            if os.name == "nt":  # Windows
                proc.terminate()
            else:  # Unix/Linux/macOS
                os.kill(proc.pid, signal.SIGTERM)
            st.session_state.monitor_process = None
            st.success("Monitoring stopped.")
        else:
            st.info("Nothing is running.")
    
if st.session_state.monitor_process and st.session_state.monitor_process.poll() is None:
    st.markdown("‚è≥ Monitoring is running...")
else:
    st.markdown("‚úÖ Monitoring is stopped.")
        
st.write('')

st.subheader('Enter emails to monitor')
name = st.text_input('Enter the Name')
mail = st.text_input('Enter the Email')

if st.button("‚úÖ Save and Continue"):
    if name and mail:
        success = add_email(name, mail)
        if success:
            st.success(f"Saved: {name} ‚Üí {mail}")
        else:
            st.warning("Name already exists. Use a unique name.")
    else:
        st.warning("Please enter both name and email.")

st.write('')

if st.button('RESET'):
    success = reset_email()

st.write("### Monitored Emails")
email_list = get_all_emails()
for n, e in email_list:
    st.write(f"**{n}**: {e}")
```

Explanation of Every Class and Function:
- **Imports**: The code imports necessary libraries: `streamlit` for the web interface, `sqlite3` for database operations, `subprocess` for running external scripts, `signal` and `os` for process management, and `json` for handling JSON data.

- **Database Setup**: A SQLite database named `emails.db` is created (if it doesn't already exist) with a table `emails` that stores names and emails.

- **Functions**:
  - **`add_email(name, email)`**: Inserts a new email entry into the database. Returns `True` if successful, or `False` if the name already exists (due to the primary key constraint).
  
  - **`reset_email()`**: Deletes all entries from the `emails` table. Returns `True` if successful.
  
  - **`get_all_emails()`**: Retrieves all email entries from the database and returns them as a list of tuples.
  
  - **`write_emails()`**: Calls `get_all_emails()` to fetch all emails and writes them to a JSON file named `email_list.json`.

- **Streamlit App**: 
  - The app title is set to "Mail Reader".
  - A session state variable `monitor_process` is initialized to manage the email monitoring process.
  - Buttons for starting and stopping the email monitoring process are provided. When "MONITOR" is clicked, it starts a subprocess running `monitor.py` and writes the current emails to a JSON file. The "STOP" button terminates the monitoring process if it is running.
  - Users can input their name and email, which are saved to the database when the "Save and Continue" button is clicked. If the name already exists, a warning is shown.
  - A "RESET" button allows users to clear all email entries from the database.
  - Finally, the app displays all monitored emails.

Input/Output Examples:
1. **Adding an Email**:
   - **Input**: User enters "Alice" as the name and "alice@example.com" as the email.
   - **Output**: If successful, the app displays "Saved: Alice ‚Üí alice@example.com". If "Alice" already exists, it shows a warning.

2. **Resetting Emails**:
   - **Input**: User clicks the "RESET" button.
   - **Output**: All email entries are deleted from the database.

3. **Monitoring Emails**:
   - **Input**: User clicks the "MONITOR" button.
   - **Output**: If monitoring starts successfully, the app shows "Monitoring started." If already running, it shows "Already running."

Called functions information:
- **`sqlite3.connect`**: Establishes a connection to the SQLite database, allowing for executing SQL commands.
  
- **`cursor.execute`**: Executes SQL commands to create tables, insert data, delete data, and retrieve data from the database.

- **`subprocess.Popen`**: Starts a new process to run the `monitor.py` script, which presumably handles email monitoring in the background.

- **`os.kill` and `proc.terminate`**: Used to stop the monitoring process based on the operating system.

- **`json.dump`**: Writes the list of emails to a JSON file, allowing for easy data export and storage.

Overall, this code provides a simple web application for managing email entries, monitoring email activity, and storing email data in a SQLite database, with a user-friendly interface built using Streamlit.