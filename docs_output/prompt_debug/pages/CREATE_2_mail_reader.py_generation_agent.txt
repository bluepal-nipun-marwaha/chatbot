The content of the file (source code) is as follows:
```python
import streamlit as st
import sqlite3
import subprocess
import signal
import os
import json

# DB Setup
conn = sqlite3.connect('emails.db', check_same_thread=False)
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS emails (
        name TEXT PRIMARY KEY,
        email TEXT NOT NULL
    )
''')
conn.commit()

# Functions
def add_email(name, email):
    try:
        cursor.execute("INSERT INTO emails (name, email) VALUES (?, ?)", (name, email))
        conn.commit()
        return True
    except sqlite3.IntegrityError:
        return False

def reset_email():
    try:
        cursor.execute('DELETE FROM emails')
        conn.commit()
        return True
    except sqlite3.IntegrityError:
        return False

def get_all_emails():
    cursor.execute('SELECT * FROM emails')
    return cursor.fetchall()

def write_emails():
    mail_list = get_all_emails()
    with open('email_list.json',  'w') as f:
        json.dump(mail_list, f)

# Streamlit App
st.title('üìß Mail Reader')

st.write('')

if 'monitor_process' not in st.session_state:
    st.session_state.monitor_process = None

st.write('Press this button to start monitoring the emails')

col1, col2, col3 = st.columns(3)

with col1:
    if st.button('MONITOR'):
        if st.session_state.monitor_process is None or st.session_state.monitor_process.poll() is not None:
            write_emails()
            st.session_state.monitor_process = subprocess.Popen(['python', 'monitor.py'])
            st.success("Monitoring started.")
        else:
            st.info("Already running.")

with col2:
    if st.button('STOP'):
        proc = st.session_state.monitor_process
        if proc and proc.poll() is None:
            if os.name == "nt":  # Windows
                proc.terminate()
            else:  # Unix/Linux/macOS
                os.kill(proc.pid, signal.SIGTERM)
            st.session_state.monitor_process = None
            st.success("Monitoring stopped.")
        else:
            st.info("Nothing is running.")
    
if st.session_state.monitor_process and st.session_state.monitor_process.poll() is None:
    st.markdown("‚è≥ Monitoring is running...")
else:
    st.markdown("‚úÖ Monitoring is stopped.")
        
st.write('')

st.subheader('Enter emails to monitor')
name = st.text_input('Enter the Name')
mail = st.text_input('Enter the Email')

if st.button("‚úÖ Save and Continue"):
    if name and mail:
        success = add_email(name, mail)
        if success:
            st.success(f"Saved: {name} ‚Üí {mail}")
        else:
            st.warning("Name already exists. Use a unique name.")
    else:
        st.warning("Please enter both name and email.")

st.write('')

if st.button('RESET'):
    success = reset_email()

st.write("### Monitored Emails")
email_list = get_all_emails()
for n, e in email_list:
    st.write(f"**{n}**: {e}")
```

Explanation of Every Class and Function:
- **Imports**: The code imports necessary libraries: `streamlit` for the web interface, `sqlite3` for database operations, `subprocess` for running external scripts, `signal` and `os` for process management, and `json` for handling JSON data.

- **Database Setup**: A SQLite database connection is established, and a table named `emails` is created if it does not already exist. This table stores names and email addresses.

- **Functions**:
  - **`add_email(name, email)`**: Inserts a new email entry into the database. Returns `True` if successful, or `False` if the name already exists (due to the primary key constraint).
  
  - **`reset_email()`**: Deletes all entries from the `emails` table. Returns `True` if successful.
  
  - **`get_all_emails()`**: Retrieves all email entries from the database and returns them as a list of tuples.
  
  - **`write_emails()`**: Calls `get_all_emails()` to fetch all email entries and writes them to a JSON file named `email_list.json`.

- **Streamlit App**: The main part of the code creates a web application interface.
  - **Title and Instructions**: Displays the title "Mail Reader" and instructions for the user.
  
  - **Monitoring Process**: Uses a session state variable to track whether the email monitoring process is running. Provides buttons to start and stop the monitoring process using `subprocess.Popen` to run an external script (`monitor.py`).
  
  - **Email Input**: Allows users to input a name and email address. When the "Save and Continue" button is clicked, it attempts to save the email using `add_email()`.
  
  - **Reset Button**: Provides functionality to reset the email list by calling `reset_email()`.
  
  - **Display Monitored Emails**: Fetches and displays all monitored emails from the database.

Input/Output Examples:
1. **Adding an Email**:
   - **Input**: User enters "Alice" as the name and "alice@example.com" as the email, then clicks "Save and Continue".
   - **Output**: If successful, the message "Saved: Alice ‚Üí alice@example.com" is displayed. If the name already exists, a warning is shown.

2. **Resetting Emails**:
   - **Input**: User clicks the "RESET" button.
   - **Output**: All email entries are deleted from the database, and the user can see the updated list of monitored emails.

3. **Starting Monitoring**:
   - **Input**: User clicks the "MONITOR" button.
   - **Output**: If monitoring is not already running, it starts the monitoring process and displays "Monitoring started." If it is already running, it shows "Already running."

Called functions information:
- **`sqlite3.connect`**: Establishes a connection to the SQLite database, allowing for data storage and retrieval.
- **`cursor.execute`**: Executes SQL commands to manipulate the database (e.g., creating tables, inserting data, deleting data).
- **`subprocess.Popen`**: Starts the external monitoring script (`monitor.py`), allowing the application to monitor emails in real-time.
- **`os.kill` and `proc.terminate`**: Used to stop the monitoring process based on the operating system.
- **`json.dump`**: Writes the list of emails to a JSON file for external use or storage.

Overall, this code provides a user-friendly interface for managing email addresses, monitoring email activity, and storing email data in a SQLite database.