
The file content (source code):
# monitor.py
import time
import json
import email
import os
import imaplib

from dotenv import load_dotenv
from twilio.rest import Client

load_dotenv()

with open('email_list.json', 'r') as f:
    mail_list = json.load(f)

monitor_emails = set(email for _, email in mail_list)

EMAIL = os.getenv("MAIL_ID")
PASSWORD = os.getenv("MAIL_PW")
IMAP_SERVER = "imap.mail.yahoo.com"

TWILIO_SID = os.getenv('TWILIO_SID')
TWILIO_AUTH_TOKEN = os.getenv('TWILIO_AUTH_TOKEN')
FROM_NUMBER = os.getenv('FROM_NUMBER')
TO_WHATSAPP = os.getenv('TO_WHATSAPP')


def fetch_unread_from_senders(senders: set):
    try:
        mail = imaplib.IMAP4_SSL(IMAP_SERVER)
        mail.login(EMAIL, PASSWORD)
        mail.select("inbox")

        status, messages = mail.search(None, '(UNSEEN)')
        if status != "OK":
            return []

        unread_ids = messages[0].split()
        matched = []

        for uid in unread_ids:
            res, msg_data = mail.fetch(uid, "(RFC822)")
            if res != "OK":
                continue

            msg = email.message_from_bytes(msg_data[0][1])
            from_header = email.utils.parseaddr(msg["From"])[1]

            if from_header in senders:
                matched.append(from_header)

        mail.logout()
        return matched
    
    except Exception as e:
        print(f"‚ùå Error during email check: {e}")
        return []

client = Client(TWILIO_SID, TWILIO_AUTH_TOKEN)

while True:
    matches = fetch_unread_from_senders(monitor_emails)
    if matches:
        print("üö® ALERT: Unread email(s) from monitored contacts:")
        for match in set(matches):
            message = client.messages.create(
                        from_=FROM_NUMBER,
                        to=TO_WHATSAPP,
                        body=f'New unread email from {match}'
                    )
            print(f"‚Üí {match}")
        print("===")
    else:
        print("‚úÖ No alert. Checking again in 30 sec...")

    time.sleep(30)
(-Source code ends-)

This is the code-level documentation for the source code and Reviewer agent's comments. Please IMPROVE the documentation according to the SUGGESTIONS, which involves adding missing function descriptions, input/output examples, or improving the clarity of the documentation. 
DO NOT DELETE/REMOVE any part of the existing documentation.
Your output should be the SAME FORMAT as the existing documentation, with the necessary improvements. 

Context: 
# monitor.py

## Overview:
The `monitor.py` script is designed to monitor unread emails from a specified list of email addresses and send notifications via WhatsApp using the Twilio API when new unread emails are detected. The script utilizes the IMAP protocol to connect to an email server, fetch unread emails, and parse the email data to identify the senders. It continuously checks for new unread emails in a loop, providing real-time alerts to the user.

Key components of the script include:
- **Email Monitoring**: The script connects to an email server and checks for unread emails from a predefined list of senders.
- **Twilio Integration**: It uses the Twilio API to send WhatsApp messages to notify the user of new unread emails.
- **Environment Configuration**: Sensitive information such as email credentials and Twilio API keys are managed using environment variables loaded from a `.env` file.
- **Error Handling**: The script includes basic error handling to manage issues that may arise during email fetching.

## FunctionDef fetch_unread_from_senders

The `fetch_unread_from_senders` function is responsible for connecting to the email server, searching for unread emails, and returning a list of senders who have unread emails. It takes a set of email addresses as input and checks for unread messages from those senders.

### Method fetch_unread_from_senders(senders: set)
This method connects to the email server using IMAP, logs in with the provided credentials, and searches for unread emails in the inbox. It then checks if the sender of each unread email is in the specified set of monitored senders.

**Parameters**:
- `senders`: A set of email addresses to monitor for unread emails.

**Returns**:
- A list of email addresses that have unread emails from the monitored senders.

**Note**: 
- Ensure that the email credentials and IMAP server settings are correctly configured in the environment variables.
- The function handles exceptions and prints error messages if any issues occur during the email fetching process.

#### Examples:
**Input Examples**: 
```python
monitor_emails = {"john@example.com", "jane@example.com"}
unread_senders = fetch_unread_from_senders(monitor_emails)
```
This input checks for unread emails from the specified senders.

**Output Example**:
```python
["john@example.com"]
```
This output indicates that there is an unread email from "john@example.com".

## Called_functions:
- **`load_dotenv()`**: Loads environment variables from a `.env` file, which is essential for managing sensitive information securely.
  
- **`imaplib.IMAP4_SSL()`**: Establishes a secure connection to the email server using the IMAP protocol, allowing for secure email fetching.

- **`email.message_from_bytes()`**: Converts the raw email bytes into a message object for easier manipulation and extraction of headers and body.

- **`email.utils.parseaddr()`**: Parses the "From" header of the email to extract the sender's email address, which is crucial for identifying monitored senders.

- **`Client.messages.create()`**: Sends a message via Twilio's API, allowing notifications to be sent to WhatsApp when unread emails are detected.

Overall, this code implements a monitoring system that checks for unread emails from specified contacts and sends notifications via WhatsApp when new unread emails are detected. It effectively integrates email fetching and messaging functionalities, providing a useful tool for email management.
Generated documentation
(-Documentation ends-)

Reviewer agent suggestions:
1. **Function Description for Missing Functions**: If there are any additional functions in the script that are not documented, please add a brief description for each function, including its purpose, parameters, and return values. This will provide a complete overview of the script's functionality.

2. **Clarification on Error Handling**: Expand the note under the `fetch_unread_from_senders` function to include specific types of exceptions that may be handled (e.g., `IMAP.error`, `ConnectionError`, etc.). This will help users understand what errors to expect and how they are managed.

3. **Detailed Examples Section**: In the `##Examples` section, consider adding more diverse input examples that cover different scenarios, such as:
   - A case where there are no unread emails from the monitored senders.
   - A case with multiple unread emails from different senders.
   This will help users understand the function's behavior in various situations.

4. **Return Value Clarification**: In the `Returns` section of the `fetch_unread_from_senders` function, clarify that the returned list may be empty if no unread emails are found. This will set the right expectations for users.

5. **Environment Configuration Details**: In the Overview section, consider adding a brief explanation of how to set up the `.env` file, including examples of the required variables (e.g., email credentials, Twilio API keys). This will assist users in configuring the script correctly.

6. **Usage Context**: In the Overview section, it may be beneficial to include a brief mention of the intended audience or use cases for this script (e.g., "This script is useful for individuals who want to stay updated on important emails without constantly checking their inbox."). This will help users understand the practical applications of the script.

7. **Function Call Context**: In the `Called_functions` section, consider adding a brief description of how each function is used within the context of the `fetch_unread_from_senders` function. This will provide clarity on the role of each called function in the overall process.

By implementing these suggestions, the documentation will become more comprehensive, user-friendly, and informative, enhancing the overall quality and usability of the script.